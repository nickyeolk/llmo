<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLMO Ranker</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; max-width: 900px; margin: 4rem auto; padding: 0 1rem; background: #f4f4f5; color: #18181b; }
        .card { background: white; padding: 2rem; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.05); border: 1px solid #e4e4e7;}
        h1 { margin-top: 0; margin-bottom: 0.75rem; font-size: 2rem; }
        .intro-text { color: #52525b; margin-bottom: 2rem; margin-top: 0; line-height: 1.6; font-size: 1.05rem; max-width: 650px; }
        
        .input-row { display: flex; gap: 1rem; align-items: flex-end; margin-bottom: 2rem; }
        .input-group { flex: 1; }
        label { display: block; margin-bottom: 0.5rem; font-weight: 600; color: #3f3f46; font-size: 0.9rem;}
        input { width: 100%; padding: 0.75rem; border: 1px solid #d4d4d8; border-radius: 6px; box-sizing: border-box; font-size: 1rem;}
        button { padding: 0.75rem 1.5rem; background: #2563eb; color: white; border: none; border-radius: 6px; font-weight: 700; font-size: 1rem; cursor: pointer; transition: background 0.2s; height: 46px; white-space: nowrap; }
        button:hover { background: #1d4ed8; }
        button:disabled { background: #93c5fd; cursor: not-allowed; }
        
        #results { margin-top: 2rem; display: flex; flex-direction: column; gap: 1rem; }
        
        /* --- NEW: HERO SCORE CARD --- */
        .score-card {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: white;
            padding: 2rem;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            display: none; /* Hidden until summary arrives */
        }
        .score-left { flex: 1; padding-right: 2rem; }
        .score-title { text-transform: uppercase; letter-spacing: 0.05em; font-size: 0.85rem; color: #94a3b8; font-weight: 700; margin-bottom: 0.5rem; }
        .score-desc { font-size: 1.1rem; line-height: 1.5; color: #e2e8f0; }
        
        /* The Big Number Circle */
        .score-circle-container { position: relative; width: 100px; height: 100px; flex-shrink: 0; }
        .score-svg { transform: rotate(-90deg); width: 100%; height: 100%; }
        .score-circle-bg { fill: none; stroke: #334155; stroke-width: 8; }
        .score-circle-fg { 
            fill: none; 
            stroke: #3b82f6; 
            stroke-width: 8; 
            stroke-dasharray: 251; /* 2 * PI * 40 */
            stroke-dashoffset: 251; /* Start empty */
            transition: stroke-dashoffset 1.5s ease-out, stroke 0.3s;
        }
        .score-number {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem; font-weight: 800;
        }
        /* --------------------------- */

        .consensus-box { background: #f8fafc; border: 1px solid #e2e8f0; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem; }
        .consensus-title { font-size: 0.85rem; text-transform: uppercase; letter-spacing: 0.05em; color: #64748b; margin-bottom: 0.5rem; font-weight: 700; }
        .consensus-text { font-size: 1.05rem; line-height: 1.6; color: #334155; }
        .consensus-text p { margin-top: 0; }
        .consensus-text strong { color: #0f172a; }

        .model-details { background: white; border: 2px solid #e4e4e7; border-radius: 8px; overflow: hidden; }
        .model-summary { background: #fafafa; padding: 1rem; font-weight: 700; font-size: 1.1rem; display: flex; justify-content: space-between; align-items: center; }
        .model-header-content { display: flex; align-items: center; justify-content: space-between; width: 100%; padding-right: 1rem; }
        .overall-score { font-size: 0.9rem; background: #18181b; color: white; padding: 0.35rem 0.75rem; border-radius: 6px; font-weight: 600; }
        
        .dimensions-container { padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; background: #fff;}
        .dim-details { border: 1px solid #e4e4e7; border-radius: 6px; }
        .dim-summary { padding: 0.75rem; font-size: 0.95rem; color: #3f3f46; background: #f8fafc;}
        .dim-summary:hover { background: #f1f5f9; }
        
        summary { display: flex; cursor: pointer; list-style: none; }
        summary::after { content: "‚ñº"; font-size: 0.8rem; color: #a1a1aa; transition: transform 0.2s; margin-left: 10px;}
        details[open] summary::after { transform: rotate(180deg); }
        .raw-text { padding: 1rem; background: #f1f5f9; border-top: 1px solid #e4e4e7; font-size: 0.9rem; color: #475569; font-family: monospace; white-space: pre-wrap; }
        .rank-badge { background: #e0f2fe; color: #0369a1; padding: 0.25rem 0.75rem; border-radius: 999px; font-weight: 700; font-size: 0.875rem; }
        .rank-badge.not-found { background: #f3f4f6; color: #64748b; font-weight: 500;}
        .rank-badge.error { background: #fee2e2; color: #991b1b; }
        .spinner { width: 16px; height: 16px; border: 2px solid #cbd5e1; border-top: 2px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; display: inline-block; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        @media (max-width: 600px) { 
            .input-row { flex-direction: column; align-items: stretch; gap: 1rem;} 
            .score-card { flex-direction: column; text-align: center; gap: 1.5rem; }
            .score-left { padding-right: 0; }
        }
    </style>
</head>
<body>
    <div class="card">
        <h1>üèÜ LLMO Ranker</h1>
        <p class="intro-text">
            As traditional SEO gives way to LLM Optimization, understanding how AI perceives your brand is critical. 
            This tool pokes a wire into the "brain" of top models to tease out their implicit tendencies and rankings.
        </p>
        
        <div class="input-row">
            <div class="input-group">
                <label for="company">Company Name</label>
                <input type="text" id="company" placeholder="Patagonia">
            </div>
            
            <div class="input-group">
                <label for="industry">Industry</label>
                <input type="text" id="industry" placeholder="Outdoor Apparel">
            </div>
            
            <button onclick="runAnalysis()" id="btn">Analyze</button>
        </div>
        
        <div id="results"></div>
    </div>

    <script>
        const models = [
            "openai/gpt-5-nano", "anthropic/claude-haiku-4.5", "meta-llama/llama-4-scout",
            "mistralai/ministral-3b-2512", "deepseek/deepseek-v3.2", "x-ai/grok-4.1-fast"
        ];

        let modelScores = {};
        // Global accumulator for the final score
        let globalScore = { totalPoints: 0, totalPossible: 0 };

        async function runAnalysis() {
            const btn = document.getElementById('btn');
            const resDiv = document.getElementById('results');
            const compInput = document.getElementById('company');
            const indInput = document.getElementById('industry');
            const company = compInput.value.trim() || compInput.getAttribute('placeholder');
            const industry = indInput.value.trim() || indInput.getAttribute('placeholder');

            if (!compInput.value) compInput.value = company;
            if (!indInput.value) indInput.value = industry;

            btn.innerText = "Analyzing...";
            btn.disabled = true;
            resDiv.innerHTML = "<div style='text-align:center; color:#666; margin-top:2rem;'>Connecting to Analysis Stream...</div>";
            modelScores = {}; 
            globalScore = { totalPoints: 0, totalPossible: 0 };

            try {
                const response = await fetch('/api/rank', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ company, industry })
                });

                const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
                let buffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    buffer += value;
                    const lines = buffer.split("\n\n");
                    buffer = lines.pop(); 

                    for (const line of lines) {
                        if (line.startsWith("event: ")) {
                            const parts = line.split("\n");
                            const eventType = parts[0].replace("event: ", "").trim();
                            const dataStr = parts[1].replace("data: ", "").trim();
                            
                            try {
                                const data = JSON.parse(dataStr);
                                handleStreamEvent(eventType, data, resDiv);
                            } catch(e) { console.error("Parse error", e); }
                        }
                    }
                }
            } catch (e) {
                resDiv.innerHTML += `<div style="color:red; margin-top:1rem;">Stream Error: ${e.message}</div>`;
            } finally {
                btn.innerText = "Analyze";
                btn.disabled = false;
            }
        }

        function handleStreamEvent(type, data, container) {
            if (type === "error") {
                container.innerHTML = `<div style="color:red; padding:1rem; border:1px solid red; border-radius:8px;">Error: ${data}</div>`;
            } 
            else if (type === "dimensions") {
                renderSkeleton(data, container);
            } 
            else if (type === "result") {
                updateResultCell(data);
            } 
            else if (type === "summary") {
                const summaryContent = document.getElementById("summary-content");
                summaryContent.innerHTML = marked.parse(data);
                
                // Show Summary Box
                document.getElementById("consensus-section").style.display = "block";
                
                // Calculate and Show Hero Score
                calculateAndShowScore();
            }
        }

        function calculateAndShowScore() {
            const scoreCard = document.getElementById("score-card");
            const scoreCircle = document.getElementById("score-fg");
            const scoreNum = document.getElementById("score-number");
            const scoreDesc = document.getElementById("score-desc");

            // Calculate percentage (avoid divide by zero)
            const finalPercent = globalScore.totalPossible > 0 
                ? Math.round((globalScore.totalPoints / globalScore.totalPossible) * 100) 
                : 0;

            scoreNum.innerText = finalPercent;
            scoreCard.style.display = "flex";
            
            // Interpret Score
            let verdict = "";
            let color = "#3b82f6"; // Blue
            if (finalPercent >= 90) { verdict = "Dominant Market Leader"; color = "#22c55e"; }
            else if (finalPercent >= 75) { verdict = "Strong Contender"; color = "#3b82f6"; }
            else if (finalPercent >= 50) { verdict = "Visible Player"; color = "#eab308"; }
            else { verdict = "Niche / Emerging"; color = "#ef4444"; }

            scoreDesc.innerText = verdict;
            scoreCircle.style.stroke = color;

            // Animate SVG Circle (Dash offset 251 -> 0 is full)
            // We want offset = 251 - (251 * percent/100)
            const offset = 251 - (251 * finalPercent / 100);
            
            // Small timeout to allow display:flex to render before animating
            setTimeout(() => {
                scoreCircle.style.strokeDashoffset = offset;
            }, 100);
            
            // Scroll to top
            scoreCard.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        function renderSkeleton(dimensions, container) {
            // Updated Skeleton to include Score Card (Hidden) and Consensus
            let html = `
                <div id="score-card" class="score-card">
                    <div class="score-left">
                        <div class="score-title">Overall LLMO Score</div>
                        <div id="score-desc" class="score-desc">Calculating...</div>
                    </div>
                    <div class="score-circle-container">
                        <svg class="score-svg" viewBox="0 0 100 100">
                            <circle class="score-circle-bg" cx="50" cy="50" r="40"></circle>
                            <circle id="score-fg" class="score-circle-fg" cx="50" cy="50" r="40"></circle>
                        </svg>
                        <div id="score-number" class="score-number">0</div>
                    </div>
                </div>

                <div id="consensus-section" class="consensus-box">
                    <div class="consensus-title">ü§ñ AI Consensus Report</div>
                    <div id="summary-content" class="consensus-text">
                        <div style="display:flex; align-items:center; gap:0.75rem; color:#64748b;">
                            <span class="spinner" style="border-color:#cbd5e1; border-top-color:#64748b;"></span>
                            <span>Synthesizing multi-model insights...</span>
                        </div>
                    </div>
                </div>
            `;

            models.forEach(model => {
                const shortName = model.split('/')[1];
                modelScores[model] = { total: 0, count: 0 };
                
                let dimsHtml = "";
                dimensions.forEach(dim => {
                    const cellId = `cell-${model}-${dim.replace(/\s+/g, '')}`;
                    dimsHtml += `
                        <details class="dim-details">
                            <summary class="dim-summary">
                                <span>${dim}</span>
                                <span id="${cellId}" class="rank-badge" style="background:#f1f5f9; color:#64748b;">
                                    <span class="spinner"></span>
                                </span>
                            </summary>
                            <div class="raw-text" id="${cellId}-raw">Waiting for data...</div>
                        </details>
                    `;
                });

                html += `
                    <details class="model-details" open>
                        <summary class="model-summary">
                            <div class="model-header-content">
                                <span>${shortName}</span>
                                <span id="score-${model}" class="overall-score">...</span>
                            </div>
                        </summary>
                        <div class="dimensions-container">${dimsHtml}</div>
                    </details>
                `;
            });
            container.innerHTML = html;
        }

        function updateResultCell(data) {
            const { model, dimension, rank, raw } = data;
            const cellId = `cell-${model}-${dimension.replace(/\s+/g, '')}`;
            
            const badgeEl = document.getElementById(cellId);
            const rawEl = document.getElementById(`${cellId}-raw`);
            
            if (badgeEl && rawEl) {
                let badgeClass = "rank-badge";
                
                // --- SCORING LOGIC ---
                // Rank 1 = 100pts, Rank 2 = 80pts, ... Rank 5 = 20pts, Unranked = 0pts
                let points = 0;
                let possible = 100;

                if (rank.includes("Error")) {
                    badgeClass += " error";
                    possible = 0; // Don't count errors against total
                } else if (rank.startsWith("#")) {
                    const r = parseInt(rank.substring(1));
                    points = Math.max(0, 120 - (r * 20)); // Formula: #1->100, #2->80, #5->20
                } else {
                    badgeClass += " not-found";
                    points = 0;
                }
                
                // Add to Global Score
                globalScore.totalPoints += points;
                globalScore.totalPossible += possible;
                // ---------------------

                badgeEl.className = badgeClass;
                badgeEl.innerHTML = rank; 
                badgeEl.style.background = ""; 
                badgeEl.style.color = "";
                rawEl.innerText = raw;

                // Update individual model average (Visual only)
                if (possible > 0) {
                    const scoreData = modelScores[model];
                    // Map points back to rank for display avg (optional, or just keep rank avg)
                    // Let's keep the existing "Avg Rank" display logic for per-model
                    let rankVal = rank.startsWith("#") ? parseInt(rank.substring(1)) : 6;
                    scoreData.total += rankVal;
                    scoreData.count++;
                    const avg = (scoreData.total / scoreData.count).toFixed(1);
                    const scoreEl = document.getElementById(`score-${model}`);
                    if (scoreEl) scoreEl.innerText = `Avg Rank: ${avg}`;
                }
            }
        }
    </script>
</body>
</html>